## Κατασκευή παιχνιδιού {#sec:game:making}

Στη συγκεκριμένη ενότητα θα δώσουμε περισσότερες λεπτομέρειες σχετικά με τον τρόπο κατασκευής του παιχνιδιού. Αυτό δεν σημαίνει πως θα αναλύσουμε τον κώδικα του παιχνιδιού γραμμή προς γραμμή. Άλλωστε, ο κώδικας περιέχει τα απαραίτητα σχόλια, που καθιστούν κατανοητή τη λειτουργία του. Αντίθετα, θα εξετάσουμε πιο εποπτικά, κάποιες ενδιαφέρουσες αποφάσεις που πάρθηκαν κατά την κατασκευή του παιχνιδιού και τον τρόπο αντιμετώπισης των προκλήσεων που προέκυψαν. Επομένως, η ενότητα αυτή δεν σχετίζεται με την τεχνητή νοημοσύνη, αλλά αποτελεί μία τεκμηρίωση των επιλογών αυτής της εργασίας και σίγουρα, θα φανεί χρήσιμη στους αναγνώστες που ενδιαφέρονται για την κατασκευή παιχνιδιού.

### Εργαλεία {#sec:game:making:tools}

Τα εργαλεία που χρησιμοποιήθηκαν για την κατασκευή του παιχνιδιού παρουσιάζονται στην *Εικόνα @fig:game:making:tools*. 

![Εργαλεία κατασκευής παιχνιδιού.](4-game/figures/tools.png){#fig:game:making:tools width=90%}

Η [Pygame](https://www.pygame.org/docs/) αποτελεί τη δημοφιλέστερη βιβλιοθήκη της Python για την κατασκευή παιχνδιών. Ο λόγος που επιλέχθηκε έναντι άλλων επιλογών, όπως η Pyglet, και η Arcade, είναι η ύπαρξη πληθώρας διαθέσιμου υλικού και παραδειγμάτων (*tutorials*) στο διαδίκτυο. Επίσης, η εξοικείωση με τη βιβλιοθήκη είναι εύκολη και γρήγορη. Για να δώσουμε μία αναφορά, χρειάστηκε περίπου μία εβδομάδα πλήρους ενασχόλησης για την εκμάθηση της Pygame σε ικανοποιητικό επίπεδο, ενώ χρειάστηκαν περί τις δύο εβδομάδες για τη συνολική κατασκευή του παιχνιδιού.

Το εργαλείο σχεδιασμού [Figma](https://www.figma.com/) χρησιμοποιήθηκε για τη δημιουργία του χάρτη του παιχνιδιού. Η χρήση του Figma μας έδωσε τη δυνατότητα να δημιουργήσουμε έναν χάρτη εξατομικευμένο στις δικές μας ανάγκες και στόχους. Βέβαια, το μεγαλύτερο πλεονέκτημα του Figma, είναι πως επέτρεψε την ακρίβεια σε επιπέδο pixel, στις θέσεις των αντικειμένων και την ανίχνευση συγκρούσεων. Για παράδειγμα, οι θέσεις των αντικειμένων στον κώδικα του παιχνιδιού ορίστηκαν στις αντίστοιχες συντεταγμένες τους, από τον χάρτη του Figma. 

Η ιστοσελίδα [OpenGameArt.org](https://opengameart.org/) παρέχει στοιχεία παιχνιδιών (*game assets*), ελεύθερα από πνευματικά δικαιώματα. Αξιοποιήθηκε για την απόκτηση της μουσικής που παίζει στο παρασκήνιο, καθώς και ηχητικών εφέ, όπως τον ήχο εκκίνησης της μηχανής του αυτοκινήτου, τον ήχο σύγκρουσης και τον ήχο εισόδου του αυτοκινήτου στη θέση στάθμευσης. 

Τα τρια τελευταία εργαλεία χρησιμοποιήθηκαν για την εύρεση και επεξεργασία εικόνων, ελεύθερων από πνευματικά δικαιώματα. Συγκεκριμένα, οι εικόνες των αυτοκινήτων του παιχνιδιού προέκυψαν από τις ιστοσελίδες [Freepik](https://www.freepik.com/) και [Pixabay](https://pixabay.com/el/), ενώ η επεξεργασία των χρωμάτων τους έγινε μέσω της ιστοσελίδας [Lunapic](https://www3.lunapic.com/editor/?action=replace-color).

### Προσωμοίωση φυσικής {#sec:game:making:motion}

Προφανώς, κύριος στόχος αυτής της εργασίας αποτέλεσε η εκπαίδευση και η σύγκριση πρακτόρων ενισχυτικής μάθησης και όχι η ανάπτυξη ενός ρεαλιστικού παιχνιδιού οδήγησης. Παρόλα αυτά, έγινε μία προσπάθεια μίμησης της φυσικής κίνησης του αυτοκινήτου, στο μεγαλύτερο δυνατό βαθμό. Ορισμένα τέτοια παραδείγματα παρουσιάζονται παρακάτω.

#### Περιστροφή {.unnumbered}

Μία πρώτη πρόκληση αποτέλεσε η περιστροφή του αυτοκινητού. Αρχικά, στην Pygame, οι συντεταγμένες ορίζονται με βάση το πάνω αριστερά σημείο ενός σχήματος. Επομένως, οι υλοποιημένες μέθοδοι που διαθέτει για την περιστροφή των αντικειμένων, περιέστρεφαν το αυτοκίνητο γύρω από το πάνω αριστερά άκρο του. Χωρίς να μπούμε σε παραπάνω τεχνικές λεπτομέρειες, η συνάρτηση μας `rotate_center` της κλάσης `AbstractCar`, πραγματοποιεί την περιστροφή του αυτοκινήτου γύρω από το κέντρο του. Επίσης, προσαρμόσαμε την γωνία περιστροφής του αυτοκινήτου, ώστε να είναι ανάλογη της ταχύτητας του και ενός παράγοντα περιστροφής. Ο παράγοντας αυτός ορίστηκε μεγαλύτερος σε μικρότερες ταχύτητες του αυτοκινήτου. Ως αποτέλεσμα, το αυτοκίνητο περιστρέφεται πιο εύκολα όταν κινείται με μικρή ταχύτητα και γίνεται λιγότερο ευέλικτο όταν κινείται με μεγάλη ταχύτητα. Τέλος, μία μετρική που χρησιμοποιήθηκε για να αξιολογηθεί η περιστροφή του αυτοκινήτου, είναι ο κύκλος στροφής του (*turning circle*). Ο κύκλος στροφής ενός οχήματος ορίζεται ως ο μικρότερος κύκλος εντός του οποίου μπορεί να στραφεί πλήρως το όχημα. Αποτελεί μέτρο της ευκολίας με την οποία το αυτοκίνητο μπορεί να παρκάρει ή να εκτελέσει μία στροφή 180° (*U-turn*). Συνήθως εκφράζεται από την εξωτερική διάμετρο του, της οποίας η μέση τιμή για τα επιβατικά αυτοκίνητα σήμερα κυμαίνεται στα 10.4-10.7m, σύμφωνα με το [@dimensionsVehicleTurning]. Στη συνέχεια, εκτελέσαμε ένα πείραμα για να μετρήσουμε τον κύκλο στροφής του αυτοκινήτου στο παιχνίδι μας. Πρώτα από όλα, πρέπει να ορίσουμε την αντιστοίχιση μεταξύ των pixel του παιχνιδιών και των μέτρων του πραγματικού κόσμου. Γνωρίζουμε πως στο παιχνίδι, το αυτοκίνητο του πράκτορα έχει διαστάσεις $82\times40$ pixels, ενώ το μέσο μήκος των αυτοκινήτων στον πραγματικό κόσμο είναι 4.9m [@carsguideAverageLength]. Επομένως, προκύπτει πως 1 pixel του παιχνιδιού αντιστοιχεί σε 0.0597m. Στο πείραμα που διεξάγαμε, εκτελέσαμε το μικρότερο δυνατό ημικύκλιο στο παιχνίδι και μετρήσαμε τις συντεταγμένες του κέντρου του αυτοκινήτου στην αρχική θέση (0°) και στην τελική θέση (180°). Οι συντεταγμένες αυτές είναι $(x_{1}, y_{1}) = (529, 692)$ και $(x_{2}, y_{2}) = (664, 692)$ αντίστοιχα. Επομένως, η διάμετρος του κύκλου στροφής προκύπτει από την εξίσωση \ref{eq:game:making:turningCircle}.
\begin{equation}
d = x_{2} - x_{1} + 2 \times distance\_to\_wheels = 664 - 529 + 2 \times 20 = 135 + 40 = 175 pixels = 10.457m 
\label{eq:game:making:turningCircle}
\end{equation}
Αξίζει να προσέψουμε πως ο όρος 2 $\times distance\_to\_wheels$, προστέθηκε καθώς μετράμε την εξωτερική διάμετρο, κι έτσι πρέπει να συνυπολογίσουμε την απόσταση μεταξύ του κέντρου του αυτοκινήτου και των τροχών του. Επομένως, ο κύκλος στροφής του αυτοκινήτου στο παιχνίδι μας αντιστοιχεί σε 10.457m, το οποίο βρίσκεται σε απόλυτη εναρμόνιση με τα πραγματικά αυτοκίνητα.

#### Ταχύτητα και τριβή {.unnumbered}

Κατά παρόμοιο τρόπο, η μέγιστη ταχύτητα του αυτόκινήτου τέθηκε στα 6px/frame, όπου κάνοντας τις κατάλληλες αντικαταστάσεις, προκύπτει ίση με 25.79km/h. Δεδομένου ότι το αυτοκίνητο κινείται εντός ενός χώρου στάθμευσης, αυτή η μέγιστη ταχύτητα θεωρείται λογική. Μάλιστα, όπως είναι αναμενόμενο, η μέγιστη ταχύτητα του πράκτορα είναι μικρότερη, όταν αυτός κινείται με την όπισθεν. Έτσι, η μέγιστη αρνητική ταχύτητα του πράκτορα ορίστηκε ίση με 4px/frame ή 17.19km/h. Ακόμα, ορίστηκε ένας συντελεστής τριβής, ο οποίος χρησιμοποιείται στη μείωση της ταχύτητας του αυτοκινήτου όταν δεν πατείται κάποιο πλήκτρο. Ο συντελεστής αυτός, τέθηκε ίσος με το μισό του συντελεστή επιτάχυνσης, που χρησιμοποιείται στην αύξηση της ταχύτητας του αυτοκινήτου κατά την πίεση των πλήκτρων. 

#### Μηχανισμός σύγκρουσης {.unnumbered}

Τέλος, στο πνέυμα της ρεαλιστικότητας του παιχνιδιού, έγινε προσπάθεια αποτύπωσης της διαδικασίας των συγκρούσεων του πραγματικού κόσμου. Έτσι, η μέθοδος `bounce` της κλάσης `AbstractCar` εκτελεί έναν μηχανισμό μικρής αναπήδησης του αυτοκινήτου, όταν αυτό συγκρούεται με κάποιο αντικείμενο. Συγκεκριμένα, σύγκρουση ανιχνεύεται στο παιχνίδι όταν, κατά την κίνηση του αυτοκινήτου του πράκτορα, αυτό εισέλθει εντός άλλου αντικειμένου. Τότε, προτού ανανεωθεί η οθόνη, πρέπει να μετακινηθεί το αυτοκίνητο εκτός του αντικειμένου. Η μέθοδος `bounce` επιτυγχάνει αυτόν τον σκοπό, αντιστρέφοντας την ταχύτητα του αυτοκινήτου και μετακινώντας το με αυτήν επανειλημμένα, μέχρι να μην συγκρούεται πλέον με το αντικείμενο. Επείτα, η ταχύτητα του αυτοκινήτου μηδενίζεται. Συνολικά, ο μηχανισμός της σύγκρουσης παρουσίασε αρκετές προκλήσεις και εμφανίστηκαν διάφορες αστοχίες (*bugs*), μέχρι να φτάσει στην τελική του μορφή. Μία από αυτές τις αστοχίες εμφανίζεται ακόμα σε μία ειδική περίπτωση (*corner case*) και αναλύεται στην υποενότητα @sec:game:making:weaknesses. Ωστόσο, το αντίκτυπο αυτής της αστοχίας είναι μικρό, ενώ συμβαίνει σπάνια. Επομένως, θεωρούμε πως ο παραπάνω μηχανισμός είναι αρκετά αξιόπιστος και επαρκής για τις ανάγκες του παιχνιδιού.

### Ενδιαφέρουσες υλοποιήσεις {#sec:game:making:interesting}

#### Frame rate {.unnumbered}

Αρχικά, επιλέχθηκε το παιχνίδι να λειτουργεί στα 20 frames per second (fps). Η απόφαση αυτή πάρθηκε, ώστε να μην επιβαρύνει σημαντικά τους υπολογιστικούς πόρους του υπολογιστή η εκτέλεση του παιχνιδιού. Η συχνότητα των 20 fps ήταν η μικρότερη δυνατή, ώστε να εξακολουθεί να φαίνεται ομαλή η κίνηση του αυτοκινήτου.  

#### Ανίχνευση σύγκρουσης {.unnumbered}

Ενδιαφέρον παρουσιάζει ο μηχανισμός που υλοποιήθηκε για την ανίχνευση σύγκρουσης. Συγκεκριμένα, χρησιμοποιείται η τεχνική της ανίχνευσης σύγκρουσης σε επίπεδο pixel (*pixel-perfect collision detection*), η οποία παρέχει ακριβή ανίχνευση, μέσω της σύγκρισης των pixel των αντικειμένων του παιχνιδιού (πχ των εικόνων των αυτοκινήτων). Συγκεκριμένα, ελέγχεται αν υπάρχουν κάποια αδιαφανή pixel δύο αντικειμένων που να συμπίπτουν. Μάλιστα, χρησιμοποιούνται μάσκες των αντικειμένων (*masks*), για τη βελτιστοποίηση και την επιτάχυνση αυτής της διαδικασίας. Οι μάσκες αποτελούν μία δυαδική αναπαράστη μίας εικόνας, όπου κάθε pixel παίρνει την τιμή 0 εάν είναι διαφανές και την τιμή 1 όταν δεν είναι, δηλ. όταν βρίσκεται το αντικείμενο στη συγκεκριμένη θέση. Έτσι, η ανίχνευση σύγκρουσης γίνεται με τη σύγκριση των μάσκων των αντικειμένων, ελέγχοντας απλώς αν δύο μάσκες έχουν την τιμή 1 στην ίδια θέση. Επομένως, στο παιχνίδι μας, δημιουργήθηκε μία μάσκα του αυτοκινήτου του πράκτορα, η οποία ανανεώνεται συνεχώς κατά την κίνηση του, και μία στατική μάσκα του χάρτη, η οποία περιέχει τα αντικείμενα με τα οποία μπορεί να προκύψει σύγκρουση. Η στατική αυτή μάσκα θα είναι διαφορετική σε κάθε επεισόδιο, ανάλογα με το ποία θέση στάθμευσης είναι ελεύθερη. Για να δημιουργηθούν αυτές οι στατικές μάσκες, χρησιμοποιήθηκαν εικόνες του χάρτη, μόνο με τα αντικείμενα σύγκρουσης του. Για παράδειγμα, για την περίπτωση όπου η δεύτερη θέση στάθμευσης είναι ελεύθερη, χρησιμοποιήθηκε η  *Εικόνα @fig:game:making:mask*.  

![Παράδειγμα εικόνας για τη δημιουργία μάσκας του χάρτη.](4-game/figures/parking-lot-border-2.png){#fig:game:making:mask width=70%}

Ωστόσο, το μειονέκτημα αυτής της μεθόδου είναι το υπολογιστικό κόστος που επιβάλλει, παρά τη χρήση μασκών. Εξάλλου, πρόκειται για έναν υπολογισμό ο οποίος θα πρέπει να εκτελείται 20 φορές το δευτερόλεπτο, καθώς το παιχνίδι λειτουργεί στα 20 fps. Στην πράξη, η υπολογιστική επιβάρυνση της τεχνικής αυτής οδήγησε σε μειωμένη απόδοση του παιχνιδιού. Η λύση σε αυτό το πρόβλημα δίνεται από την πολύ φθηνότερη μέθοδο της ανίχνευσης σύγκρουσης ορθογωνίων σχημάτων (*rectangle collision detection*). Συγκεκριμένα, τα αντικείμενα του χάρτη στα οποία μπορεί να προκύψει σύγκρουση (δηλ. αυτοκίνητα, κήπος, τοίχοι), αναπαρίστανται στο παιχνίδι ως ορθογώνια παραλληλόγραμμα, τα οποία καλύπτονται στην οθόνη του παιχνιδιού από τις αντίστοιχες εικόνες. Έτσι, το αυτοκίνητο του πράκτορα αναπαρίσταται από ένα ορθογώνιο παραλληλόγραμμο, το οποίο και παίζει σημαντικό ρόλο στο μηχανισμό της περιστροφής του αυτοκινήτου. Επομένως, μπορεί να πραγματοποιηυεί η ανίχνευση συγκρούσεων με τη μέθοδο των ορθογωνίων σχημάτων, η οποία ελέγχει αν δύο ορθογώνια σχήματα επικαλύπτονται. Ωστόσο, ενδέχεται να προκύψουν λάθη από τη χρήση της μεθόδου. Συγκεκριμένα, το ορθογώνιο του αυτοκινήτου, δεν περιβάλλει πάντα ακριβώς, την εικόνα του αυτοκινήτου. Πιο αναλυτικά, όταν η εικόνα του αυτοκινήτου βρίσκεται υπό γωνία, τότε το ορθογώνιο του αυτοκινήτου είναι μεγαλύτερο από αυτήν, όπως φαίνεται στην *Εικόνα @fig:game:making:car-rectangle*. 

![Ορθογώνιο αυτοκινήτου έναντι εικόνας αυτοκινήτου. Παρατηρούμε πως η ανίχνευσης σύγκρουσης με τη μέθοδο των ορθογωνίων σχημάτων μπορεί να είναι ανακριβής.](4-game/figures/black-rectangle.png){#fig:game:making:car-rectangle width=70%}

Το γεγονός αυτό, προκαλεί ψευδώς θετικές συγκρούσεις, δηλαδή περιπτώσεις στις οποίες συγκρούεται μόνο το ορθογώνιο του αυτοκινήτου και όχι η εικόνα του, όπως βλέπουμε στην ίδια εικόνα. Επομένως, η τελική λύση που επιλέχθηκε αποτελεί έναν συνδυασμό των δύο μεθόδων. Αρχικά, πραγματοποιείται η ανίχνευση σύγκρουσης με τη μέθοδο των ορθογωνίων σχημάτων, και εφόσον αυτή επιβεβαιωθεί, τότε εφαρμόζεται η ανίχνευση σύγκρουσης με τη μέθοδο των pixel. Έτσι, εξασφαλίζεται τόσο η ακρίβεια της ανίχνευσης, όσο και η ελαχιστοποίηση του υπολογιστικού κόστους.

Με τις ίδιες τεχνικές πραγματοποιείται και η ανίχνευση της εισόδου του αυτοκινήτου, εντός της ελεύθερης θέσης στάθμευσης. Το ενδιαφέρον που παρουσιάζεται εδώ, έγκειται στο γεγονός πως η μέθοδο των pixel εφαρμόζεται ανάποδα σε σχέση με πριν. Συγκεκριμένα, όπως και πριν, πρώτα ανιχνεύεται η σύγκρουση του ορθογωνίου του αυτοκινήτου με το ορθογώνιο της θέσης στάθμευσης, και εφόσον αυτή επιβεβαιωθεί, τότε εφαρμόζεται η ανίχνευση με τη μέθοδο των pixel. Ωστόσο, τώρα χρειάζονται νέες μάσκες, οι οποίες δημιουργούνται από εικόνες όπως η *Εικόνα @fig:game:making:free-spot-border-2*, για την περίπτωση πάλι, της δεύτερης θέσης στάθμευσης. 

![Παράδειγμα εικόνας για τη δημιουργία μάσκας της ελεύθερης θέσης στάθμευσης.](4-game/figures/free-spot-border-2.png){#fig:game:making:free-spot-border-2 width=70%}

Όπως γίνεται κατανοητό και από την εικόνα, πλέον ελέγχεται αν δεν υπάρχει σύγκρουση με την παραπάνω μάσκα, δηλ. το αυτοκίνητο έχει εισέλθει ολόκληρο εντός της ελεύθερης θέσης.

#### Εκκίνηση από τυχαία θέση {.unnumbered}

Στη συνέχεια, έχοντας πλέον αναφερθεί στην έννοια του ορθογωνίου του αυτοκινήτου, μπορεούμε να σχολιάσουμε την ιδιότητα του πράκτορα να ξεκινάει από τυχαία θέση και γωνία, στην αρχή του κάθε επεισοδίου (*random spawn*). Για να υλοποιηθεί αυτή η ιδιότητα, έπρεπε να καθορίσουμε τις συντεταγμένες (x,y) από τις οποίες θα μπορούσε να ξεκινήσει ο πράκτορας. Ζητούμενο προφανώς είναι, ο πράκτορας να μην ξεκινάει από παράνομη θέση, δηλ. θέση στην οποία συγκρούεται. Ο υπολογισμός των δυνατών θέσεων εκκίνησης του αυτοκινήτου έγινε μέσω του Figma και αυτές παρουσιάζονται με γαλάζιο χρώμα στην *Εικόνα @fig:game:making:parking-lot-spawns*.

![Δυνατές θέσεις εκκίνησης του αυτοκινήτου.](4-game/figures/parking-lot-spawns.png){#fig:game:making:parking-lot-spawns width=70%}

Στην παραπάνω εικόνα, τα γαλάζια παραλληλόγραμμα αντιπροσωπεύουν τις δυνατές περιοχές εκκίνησης του αυτοκινήτου, ενώ το κόκκινο παραλληλόγραμμο αντιπροσωπεύει το ορθογώνιο του αυτοκινήτου. Προκειμένου να γίνει κατανοητή η εικόνα, οφείλουν να γίνουν δύο παρατηρήσεις:
- Η πρώτη παρατήρηση σχετίζεται με τις διαστάσεις του ορθογωνίου του αυτοκινήτου. Οι διαστάσεις αυτές, εξαρτάται από την γωνία του αυτοκινήτου. Για παράδειγμα, αν η γωνία του αυτοκινήτου είναι 0°, τότε το μήκος του ορθογωνιού θα είναι 82px και το πλάτος του 40px, με βάση τις διαστάσεις της εικόνας του αυτοκινήτου. Αν όμως η γωνία του αυτοκινήτου είναι 90°, τότε το μήκος και το πλάτος του ορθογωνίου θα είναι ανάποδα. Επειδή η γωνία έναρξης είναι τυχαία, δεν ακριβώς ποιές θα είναι οι διαστάσεις του ορθογωνίου του αυτοκινήτου. Για αυτό, θεωρούμε τη μέγιστη τιμή που μπορούν να πάρουν, δηλ. 82px. Άρα, το ορθογώνιο του αυτοκινήτου που φαίνεται στην *Εικόνα @fig:game:making:parking-lot-spawns*, έχει διαστάσεις 82 $\times$ 82px.
- Η δεύτερη παρατήρηση αφορά την ιδιότητα πως στην Pygame, οι συντεταγμένες ορίζονται με βάση το πάνω αριστερά σημείο ενός σχήματος. Επομένως, τα γαλάζια παραλληλόγραμμα έχουν σχεδιαστεί κατάλληλα, έτσι ώστε όταν το πάνω αριστερά άκρο του ορθογωνίου του αυτοκινήτου βρίσκεται εντός τους, να μην προκύπτει σύγκρουση. Στην *Εικόνα @fig:game:making:parking-lot-spawns* παρουσιάζεται μία ακραία περίπτωση αυτού του παραδείγματος, όπου η άκρη του ορθογωνίου του αυτοκινήτου βρίσκεται στην άκρη ενός γαλάζιου παραλληλογράμμου και παρόλα αυτά, δεν προκύπτει κάποια σύγκρουση.

Βέβαια, με αυτόν τον τρόπο περιορίζονται οι δυνατές θέσεις εκκίνησης του αυτοκινήτου, διότι αποκλείονται κάποιοι συνδυασμοί συντεταγμένων και γωνίας εκκίνησης, οι οποίοι δεν θα προκαλούσαν σύγκρουση. Παρόλα αυτά, το πλήθος σημείων αυτών των παραλληλογράμμων, σε συνδυασμό με όλες τις πιθανές γωνίες εκκίνησης του αυτοκινήτου (0°-360°), δημιουργούν έναν τεράστιο και ποικιλόμορφο χώρο εκκίνησης, ο οποίος σίγουρα επαρκεί για την γενίκευση του πράκτορα.

#### Αισθητήρες {.unnumbered}

Προκειμένου ο πράκτορας να αντιλαμβάνεται το περιβάλλον γύρω του, επιλέχθηκε μία από τις δημοφιλέστερες μορφές αισθητήρων για τέτοιου είδους παιχνίδια, οι ακτίνες (*raycasts*). Οι ακτίνες είναι ευθύγραμμες γραμμές που εκτείνονται από τον πράκτορα προς τα έξω και με βάση το μήκος τους, ο πράκτορας μπορεί να εκτιμήσει τις αποστάσεις με τα αντικείμενα γύρω του. Δεν υπάρχει κάποια σχετική μέθοδος στην Pygame για το μηχανισμό αυτό, επομένως η υλοποίηση των ακτίνων έγινε από την αρχή. Η διαδικασία που ακολουθήθηκε για τη σχεδίαση των ακτίνων, παρουσιάζει ενδιαφέρον ως προς τη μείωση του υπολογιστικού κόστους. Συγκεκριμένα, η σχεδίαση μίας ακτίνας ξεκινάει από το κέντρο του αυτοκινήτου του πράκτορα και συνεχίζει μέχρι να συναντήσει κάποιο εμπόδιο ή έως ότου φτάσει στο μέγιστο μήκος της. Η ανίχνευση των εμποδίων γίνεται ξανά με τη χρήση της μάσκας του χάρτη, ελέγχωντας αν το σημείο στο άκρο της ακτίνας έχει την τιμή 1 στη μάσκα (δηλ. βρίσκεται αντικείμενο στο σημείο) ή 0 (δηλ. το σημείο είναι ελεύθερο). Όμως, αποδείχθηκε ότι η αύξηση της ακτίνας κατά 1 pixel τη φορά, προκαλεί πολύ μεγάλο υπολογιστικό κόστος. Αυτό είναι λογικό, αν αναλογιστεί κανείς πως το μέγιστο μήκος της ακτίνας είναι 200px (θα εξηγήσουμε παρακάτω γιατί), πως υπάρχουν συνολικά 8 ακτίνες και πως η ανίχνευση αντικειμένων πρέπει να γίνει σε κάθε frame, δηλ. 20 φορές το δευτερόλεπτο. Το αποτέλεσμα ήταν η εμφανής μείωση της απόδοσης του παιχνιδιού. Επομένως, η λύση που επιλέχθηκε ήταν η αύξηση της ακτίνας κατά ένα βήμα των 20px τη φορά. Όταν ανιχνευτεί αντικείμενο, τότε το μήκος της ακτίνας μειώνεται κατά 1 επαναληπτικά, έως ότου βρεθεί η αρχή του αντικειμένου. Το μέγεθος του βήματος ορίστηκε στα 20px και όχι πιο μεγάλο, ώστε να αποφευχθεί το πρόβλημα της υπερπήδησης των αντικειμένων από την ακτίνα, το οποίο συνέβαινε με μεγαλύτερα βήματα, όταν η ακτίνα περνούσε από ακμές των αντικειμένων. Επομένως, με τον τρόπο που περιγράψαμε εξασφαλίζεται η ακρίβεια της ανίχνευσης, ενώ ταυτόχρονα μειώνεται σημαντικά το υπολογιστικό κόστος.

Η λογική πίσω από την επιλογή του μέγιστου μήκους της ακτίνας, ήταν η παροχή έγκαιρης ενημέρωσης στον πράκτορα. Συγκεκριμένα, είναι επιθυμητό, ακόμα και όταν ο πράκτορας κινείται με τη μέγιστη ταχύτητα (6px), η ακτίνα να τον προειδοποιησει για την ύπαρξη εμποδίου αρκούντως νωρίς, ώστε αν πατήσει εκεινή τη στιγμή το αντίθετο πλήκτρο (DOWN), να προλάβει να σταματήσει προτού συγκρουστεί. Ο υπολογισμός του απαιτούμενου μήκους για να ισχύει αυτή η συνθήκη, περιγράφεται παρακάτω.

Αρχικά, ας υπολογίσουμε το πλήθος των frames που θα χρειαστεί το αυτοκίνητο για να σταματήσει ($f$), με δεδομένο ότι η αρχική του ταχύτητα είναι $u_0 = 6$px/frame, η τελική του ταχύτητα είναι $u_f = 0$px/frame και η επιτάχυνση του αυτοκινήτου είναι $a = -0.1$px/frame$^2$. Από την κινηματική, γνωρίζουμε ότι ισχύει η εξίσωση \ref{eq:game:making:velocity}, για την ταχύτητα του αυτοκινήτου σε κάθε frame $n$:
\begin{equation}
u(n) = u_0 + a \cdot n
\label{eq:game:making:velocity}
\end{equation} 
Αντικαθιστώντας για $n=f$ και με βάση τα παραπάνω δεδομένα, προκύπτει ότι $f = 60$ frames.

Στη συνέχεια, θα υπολογίσουμε την τελική απόσταση $d$, που θα διανύσει το αυτοκίνητο σε αυτά τα 60 frames. Η απόσταση αυτή δίνεται από το άθροισμα των αποστάσεων που διήνυσε το αυτοκίνητο σε κάθε frame, δηλ. την ταχύτητα του αυτοκινήτου σε κάθε frame (εξίσωση \ref{eq:game:making:distance}):
\begin{equation}
\label{eq:game:making:distance}
d = \sum_{i=1}^{f} u(i) = \sum_{i=1}^{f} (u_0 + a \cdot i) = \sum_{i=1}^{60} (6 - 0.1 \cdot i)
\end{equation}
Αυτό το άθροισμα υπολογίζεται χρησιμοποιώντας τον αντίστοιχο τύπο των αριθμητικών σειρών, που δίνεται στην εξίσωση \ref{eq:game:making:sum}:
\begin{equation}
d = \frac{f}{2} \cdot (u_0 + u_f) = \frac{60}{2} \cdot (6 + 0.1) = 183 \text{ pixels}
\label{eq:game:making:sum}
\end{equation}	
Άρα, προκύπτει πως το αυτοκίνητο θα χρειαστεί 183 pixels για να σταματήσει. Ωστόσο, επιλέξαμε να μην υπάρχει ακτίνα κάθετη στο αυτοκίνητο (δηλ. με γωνία 90°), για λόγους που θα εξηγηθούν στην υποενότητα @sec:game:making:weaknesses. Η κοντινότερη ακτίνα προς την κατεύθυνση της κίνησης του πράκτορα έχει γωνία 75°, επομένως μπορούμε να υπολογίσουμε το απαραίτητο μήκος αυτής μέσω τριγωνομετρίας, στο ορθογώνιο τρίγωνο που σχηματίζεται (εξίσωση \ref{eq:game:making:ray}):
\begin{equation}
\label{eq:game:making:ray}
\text{μήκος\_ακτίνας} = \frac{\text{μήκος\_καθέτου}}{\cos(15°)} = 190 \text{ pixels}
\end{equation}
Επομένως, το απαιτούμενο μήκος των ακτινών΄μας είναι 190 pixels. Επιλέξαμε την στρογγυλοποίηση της τιμής αυτής στα 200 pixels, ώστε να αφήσουμε ένα μικρό περιθώριο αντίδρασης στους παίκτες του παιχνιδιού. 

#### Φιγούρες αυτοκινήτων {.unnumbered}

Τέλος, μία καθαρά αισθητική παρατήρηση αφορά τις εικόνες των αυτοκινήτων. Συγκεκριμένα, επιλέχθηκαν 4 διαφορετικοί τύποι σταθμευμένων αυτοκινήτων με διαφορετικά χρώματα. Σε κάθε επεισόδιο, η κατανομή των τύπων αυτοκινήτων σε θέσεις είναι τυχαία, αλλά πάντα θα βρίσκεται τουλάχιστον ένα αυτοκίνητο από κάθε τύπο. Με τον τρόπο αυτό, τα επεισόδια διαφέρουν μεταξύ τους και προστίθεται ποικιλία στο παιχνίδι. Ακόμα, δημιουργήθηκαν πολλές παραλλαγές του αυτοκινήτου του πράκτορα, με διαφορετικό χρώμα για κάθε αλγόριθμο. Συνολικά όμως, τα χρώματα όλων των αυτοκινήτων επελέγησαν έτσι, ώστε να διαφέρουν σημαντικά μεταξύ τους και να διακρίνονται εύκολα από όλους τους παίκτες.

### Αδυναμίες {#sec:game:making:weaknesses}

#### Μηχανισμός σύγκρουσης {.unnumbered}

Όπως προαναφέρθηκε, είναι γνωστή μία αστοχία του παιχνιδιού, η οποία σχετίζεται με τον μηχανισμό της σύγκρουσης. Συγκεκριμένα, όταν το αυτοκίνητο συγκρουστεί με ένα άλλο αντικείμενο, τότε το παιχνίδι θα το μετακινεί προς την αντίθετη κατεύθυνση επαναλαμβανόμενα,μέχρι να σταματήσει να συγκρούεται. Η αστοχία εμφανίζεται, όταν κατά τη μετακίνηση του αυτοκινήτου προς την αντίθετη κατεύθυνση, προκύψει δεύτερη σύγκρουση, με άλλο αντικείμενο. Τότε, δεν σταματάει η επανάληψη της μετακίνησης του αυτοκινήτου, αλλά συνεχίζεται έως ότου το αυτοκίνητο να μην συγκρούεται με κανένα αντικείμενο. Αυτό μπορεί να συμβεί σε 2 περιπτώσεις, οι οποίες παρουσιάζονται παρακάτω, μαζί με τις μεθόδους αντιμετώπισης που χρησιμοποιήθηκαν:

1. Όταν το αυτοκίνητο βρίσκεται ανάμεσα σε δύο σταθμευμένα οχήματα. Να σημειωθεί πως υπάρχει ικανός χώρος, ώστε ο παίκτης να τοποθετήσει το αυτοκίνητο του μεταξύ δύο άλλων οχημάτων. Τότε, η αστοχία θα παρουσιαστεί αν το αυτοκίνητο συγκρουστεί με το πρώτο σταθμευμένο όχημα, με τρόπο τέτοιο ώστε η αναπήδηση του προς τα πίσω να το ωθήσει να συγκρουστεί με το δεύτερο σταθμευμένο όχημα. Σε αυτήν την περίπτωση, το αυτοκίνητο θα εμφανιστεί απότομα στον παίκτη πίσω από το δεύτερο σταθμευμένο όχημα. Αυτή η εξέλιξη, παρόλο που δεν είχε σχεδιαστεί, εντούτοις δεν είναι πλήρως ανεπιθύμητη. Συγκεκριμένα, μπορεί να θεωρηθεί ως χαρακτηριστικό του παιχνιδιού, προκειμένου να απεγκλωβίζει το αυτοκίνητο του παίκτη, όταν αυτό έχει κολλήσει στον στενό χώρο μεταξύ δύο άλλων οχημάτων.
1. Όταν το αυτοκίνητο βρίσκεται υπό γωνία στις 4 άκρες του χάρτη. Συγκεκριμένα, περιμετρικά του χάρτη υπάρχει ένας λεπτός τοίχος, ώστε να εμποδίζει το αυτοκίνητο από το να βγαίνει εκτός των ορίων του. Έτσι, μπορεί να δημιουργηθεί η ίδια συνθήκη με πριν, όπου για παράδειγμα, το ρόλο του πρώτου οχήματος παίζει ένας κατακόρυφος τοίχος και το ρόλο του δεύτερου οχήματος παίζει ένας οριζόντιος τοίχος. Ωστόσο, αυτή η περίπτωση είναι πιο σοβαρή, καθώς μετά τη μετακίνηση του, το αυτοκίνητο καταλήγει εκτός χάρτη. Για αυτό τότε, το αυτοκίνητο μεταφέρεται αυτόματα εντός του χάρτη, σε τυχαία θέση και γωνία.

Προφανώς, οι εξελίξεις των παραπάνω σεναρίων δεν αντικατοπτρίζουν τον πραγματικό κόσμο. Ωστόσο, δεν είναι καταστροφικά για το παιχνίδι, αφού ακόμα και στην σπάνια περίπτωση όπου συμβούν οι περιπτώσεις αυτές, το επεισόδιο μπορεί ύστερα να συνεχιστεί κανονικά. Γενικότερα, ο μηχανισμός της σύγκρουσης παρουσιάσε αρκετά προβλήματα, εκ των οποίων η επίλυση του ενός, συχνά προκαλούσε τη δημιουργία του άλλου. Επομένως αυτή η υλοποίηση, θεωρήθηκε η καλύτερη δυνάτη, με δεδομένο ότι βασίζεται πλήρως στη βιβλιοθήκη Pygame, την οποία χρησιμοποιήσαμε. Για καλύτερα αποτελέσματα, θα μπορούσε κάποιος να στραφεί σε άλλες βιβλιοθήκες, εξειδικευμένες στην προσομοίωση μηχανισμών φυσικής όπως πχ η Pymunk.

#### Μηχανισμός αισθητήρων {.unnumbered}

Ο μηχανισμός των αισθητήρων που υλοποιήθηκε, δηλ. η τεχνική raycasting, είναι αρκετά απλοϊκή και μπορεί να αποδειχθεί ανεπαρκής, σε ορισμένες περιπτώσεις. Συγκεκριμένα, μπορεί ένα αντικείμενο να είναι αρκετά λεπτό ή υπό κατάλληλη γωνία, ώστε να μην ανιχνευτεί από τις ακτίνες. Προσπαθήσαμε να περιορίσουμε αυτό το φαινόμενο, επιλέγοντας κατάλληλες γωνίες ακτίνων, ώστε αυτές να παρέχουν πληροφορία για αντικείμενα που βρίσκονται προς τα μπροστά ή προς τα πίσω σε σχέση με το αυτοκίνητο. Επομένως, πυκνώσαμε τις ακτίνες στις κατευθύνσεις στις οποίες, το αυτοκίνητο μπορεί να κινηθεί. Ωστόσο, προβλήματα αυτού του είδους μπορούν ακόμα να εμφανιστούν, όπως αποδεικνύει η *Εικόνα @fig:game:making:raycasting*.

![Παράδειγμα ανεπάρκειας των αισθητήρων. Παρατηρούμε ότι δεν ανισχνεύεται το ροζ αυτοκίνητο, παρόλο που βρίσκεται εντός του βεληνεκούς των ακτίνων.](4-game/figures/raycasting3.png){#fig:game:making:raycasting width=70%}

Μία προφανής λύση σε αυτό το ζήτημα είναι η αύξηση του πλήθους των ακτίνων. Όμως αυτό δεν επιλέχθηκε, πρώτον για λόγους διατήρησης του υπολογιστικού φορτίου του παιχνιδιού σε χαμηλά επίπεδα και δεύτερον για λόγους μείωσης της πολυπλοκότητας του νευρωνικού δικτύου του πράκτορα. Συγκεκριμένα, η αύξηση του πλήθους των ακτίνων θα σήμαινε αύξηση των εισόδων του δικτύου, το οποίο θα οδηγούσε σε πιο αργή και δύσκολη εκπαίδευση [@venturebeatDebateOver]. Άλλωστε, οι περισσότερες εργασίες που κάνουν χρήση της τεχνικής raycasting, χρησιμοποιούν παρόμοιο αριθμό ακτίνων και επιβεβαιώθηκε στην πράξη, μέσω της εκπαίδευσης, πως οι πράκτορες δεν δυσκολεύτηκαν να μάθουν να αποφεύγουν τις συγκρούσεις. Επομένως, παραδείγματα αστοχιών ανίχνευσης όπως αυτό της εικόνας @fig:game:making:raycasting, θεωρούνται αμελητέα, για την επίτευξη του στόχου της εργασίας.