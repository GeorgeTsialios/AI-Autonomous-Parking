## Η αρχιτεκτονική Model-View-ViewModel (MVVM) {#sec:implementation:mvvm}

Ήδη στην Ενότητα @sec:literature:crossPlatformApps:Flutter, αναφέρθηκε το "widget" ως στοιχειώδης μονάδα τμήματος κώδικα μίας εφαρμογής, με το framework Flutter. Κάθε οθόνη της εφαρμογής είναι ένα widget, το οποίο αποτελείται από άλλα, επιμέρους widgets, όπως κουμπιά, κείμενα, εικόνες κ.λπ. Τα widgets αποτελούνται επιπλέον από συναρτήσεις - μεθόδους, τα αποτελέσματα των οποίων μπορούν να χρησιμοποιηθούν, ώστε να προβληθούν στον χρήστη.

Σε αυτό το πνεύμα, είναι απολύτως αποδεκτό ολόκληρη η λογική της εφαρμογής να τοποθετηθεί σε μεθόδους των αντίστοιχων widgets, ωστόσο κάτι τέτοιο αποτελεί κακή προγραμματιστική και αρχιτεκτονική πρακτική, μιας και οδηγεί γρήγορα σε πολύπλεξη του κώδικα και επαναχρησιμοποίηση τμημάτων λογικής. Για τον λόγο αυτό, έχουν αναπτυχθεί κάποιες αρχιτεκτονικές ή μοτίβα (design patterns), όπως το Model-View-Controller (MVC), το Model-View-ViewModel (MVVM) και το Model-View-Presenter (MVP) [@Lou2016].

Για τη δόμηση της εφαρμογής **Horario** επιλέξαμε την αρχιτεκτονική Model-View-ViewModel (MVVM). Το MVVM είναι μία παραλλαγή της γηραιότερης αρχιτεκτονικής MVC, που προτάθηκε το 2005 από αρχιτέκτονες λογισμικού της Microsoft, με σκοπό να κάνει την ανάπτυξη Windows προγραμμάτων, των μορφών WPF (Windows Presentation Foundation) και Silverlight, ευκολότερη [@Gossman2005]. Η φιλοσοφία της αρχιτεκτονικής MVVM στηρίζεται στον διαχωρισμό των αρμοδιοτήτων (separation of concerns), μεταξύ των επιμέρους τμημάτων κώδικα.

Η αρχιτεκτονική MVVM αποτελείται από τα ακόλουθα 3 τμήματα [@Garca2023], [@Anderson2012]:

- **Model**: είναι το τμήμα κώδικα που χειρίζεται τα δεδομένα και επικοινωνεί με τις μονάδες αποθήκευσης. Αρμοδιότητα του Model είναι να μεταφέρει δεδομένα από και προς τη βάση δεδομένων, επομένως εξαρτάται άμεσα από την επιλογή του συστήματος διαχείρισης βάσης δεδομένων. Κάθε Model θα πρέπει να υλοποιεί ένα interface, ώστε τα δεδομένα που καθιστά προσβάσιμα να είναι μορφολογίας συμβατής με τα υπόλοιπα τμήματα του MVVM.
- **View**: είναι το τμήμα κώδικα με το οποίο έρχεται σε επαφή ο χρήστης. Το View σχεδιάζει τις γραφικές διεπαφές της εφαρμογής (δηλαδή τις επιμέρους οθόνες), φροντίζοντας πάντα να εμφανίζεται στον χρήστη ανανεωμένη πληροφορία. Το View χρησιμοποιεί δεδομένα συγκεκριμένης μορφής, τα οποία προετοιμάζει το Model (με βάση το interface που προαναφέρθηκε), χωρίς όμως αυτά τα δύο τμήματα να επικοινωνούν απευθείας μεταξύ τους.
- **ViewModel**: είναι το ενδιάμεσο τμήμα κώδικα μεταξύ Model και View. Το View συμπλέκεται σε δεδομένα του ViewModel (data binding), όπως ιδιότητες (properties) και πεδία (fields), και τα οποία καθορίζουν τη συμπεριφορά και τις λειτουργίες του View. Για παράδειγμα, ένα κουμπί του View συμπλέκεται σε μία μέθοδο του ViewModel, η οποία καλείται όταν ο χρήστης πατάει το κουμπί. Ένα αντίστοιχο data binding με ένα property του ViewModel μπορεί να καθορίσει εάν το κουμπί είναι ενεργοποιημένο ή απενεργοποιημένο.

Σκοπός της αρχιτεκτονικής MVVM είναι η πλήρης αποσύμπλεξη του Model από το View και η επικοινωνία τους μονάχα μέσω του ViewModel. Οι σχέσεις μεταξύ Model, View και ViewModel είναι πολλά-προς-πολλά (many-to-many). Έτσι, ένα View μπορεί να συμπλέκεται με περισσότερα από ένα ViewModels και σε ένα ViewModel να συμπλέκονται περισσότερα από ένα Views. Επιπλέον, με αυτόν τον τρόπο, όλο το front-end της εφαρμογής είναι πλήρως ανεξάρτητο από το back-end, με την έννοια ότι, εάν κάποια στιγμή οι αρχιτέκτονες αποφασίσουν να μεταναστεύσουν (migrate) σε ένα διαφορετικό σύστημα διαχείρισης βάσης δεδομένων, οι προγραμματιστές θα αρκεί να υλοποιήσουν το interface του Model για το αντίστοιχο σύστημα, αφήνοντας το View και το ViewModel αναλλοίωτα.

Ας εξετάσουμε, επί παραδείγματι, την Αρχική οθόνη της εφαρμογής **Horario** (βλ. Ενότητα @sec:design:prototypes:homePage). Θεωρώντας την ως ένα View, χρειάζεται ως δεδομένα τον ενεργό χρήστη και τις επερχόμενες βάρδιές του. Οι επερχόμενες βάρδιες αποτελούν ιδιότητα του ViewModel της Οθόνης προγράμματος, αφού όλες οι σχετικές με πρόγραμμα λειτουργίες επιτελούνται από το συγκεκριμένο ViewModel. Έτσι, θα ήταν εσφαλμένη πρακτική να προσθέσουμε business logic στο ViewModel της Αρχικής οθόνης για την ανάκτηση των επερχόμενων βαρδιών, μιας και θα οδηγούσε σε επαναλαμβανόμενο κώδικα. Αντίθετα, το Home-Page-View κάνει χρήση ιδιότητας του Schedule-Page-ViewModel, οδηγώντας σε ξεκάθαρο διαχωρισμό αρμοδιοτήτων (separation of concerns). Από την αντίθετη οπτική, στην ίδια ιδιότητα του Schedule-Page-ViewModel συμπλέκεται τόσο η Αρχική οθόνη, για τις επερχόμενες βάρδιες, αλλά και η Οθόνη προγράμματος, για την Ατομική της προβολή.

Ας εστιάσουμε σε ένα βασικό ζητούμενο της αρχιτεκτονικής MVVM. Η σύμπλεξη δεδομένων (data binding) μεταξύ View και ViewModel πρέπει να είναι διαρκώς ενημερωμένη. Αυτό σημαίνει ότι μία αλλαγή που προκαλείται σε μία ιδιότητα (property) του ViewModel, είτε προκαλείται από μέθοδο του ίδιου του ViewModel, είτε από δεδομένα που προήλθαν από το Model, θα πρέπει να αντικατοπτρίζεται αμέσως στο View, χωρίς να εμφανίζονται ασυμφωνίες.

Επομένως, το ViewModel πρέπει πάντα να "ειδοποιεί" (notify) το View σχετικά με αλλαγές στις ιδιότητές του, ή, με άλλα λόγια, οι ιδιότητες του ViewModel να είναι "παρατηρήσιμες" (observable) από το View. Η λειτουργικότητα αυτή αποτελεί βασικό στοιχείο της αρχιτεκτονικής MVVM και, γι' αυτό, υλοποιείται από βιβλιοθήκες στα περισσότερα frameworks που στηρίζονται στο MVVM.

Για το Flutter, η βιβλιοθήκη **Riverpod** μπορεί να χρησιμοποιηθεί για αυτόν τον σκοπό. Βασικός σκοπός της βιβλιοθήκης Riverpod είναι η αποδοτική διαχείριση της κατάστασης της εφαρμογής (state management), με τη χρήση Παρόχων (Providers), Καταναλωτών (Consumers) και Ειδοποιητών (Notifiers). Χρησιμοποιούμε αυτά τα χαρακτηριστικά για την υλοποίηση της αρχιτεκτονικής MVVM ως εξής: το κάθε View (η κάθε οθόνη της εφαρμογής) είναι ένας Consumer, ο οποίος παρακολουθεί αλλαγές των Providers (και, ως εκ τούτου, ενημερώνεται αυτόματα από το Riverpod). Η κάθε ιδιότητα (property) του κάθε ViewModel είναι ένας Provider (για την ακρίβεια, ένας NotifierProvider, δηλαδή ένας Provider που έχει τη δυνατότητα να ειδοποιεί τους καταναλωτές του). Αυτούς τους Providers παρακολουθούν τα Views για αλλαγές. Όταν, λοιπόν, το ViewModel επιθυμεί να τροποποιήσει μία ιδιότητά του, αλλάζει το περιεχόμενο ενός Provider, ενώ ο αντίστοιχος Notifier στέλνει σήμα τροποποίησης στο View, το οποίο ενημερώνεται αμέσως.
