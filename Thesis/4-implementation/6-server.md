## Μηχανή αυτόματης ανάθεσης βαρδιών {#sec:implementation:server}

### Υλοποίηση αλγορίθμου {#sec:implementation:server:algorithm}

Κεντρικό σημείο της εφαρμογής **Horario** αποτελεί η μηχανή αυτόματης ανάθεσης βαρδιών, η οποία εκτελείται όταν ο χρήστης δημιουργεί ένα νέο ή επεξεργάζεται ένα υπάρχον πρόγραμμα εργασίας και επιλέξει τουλάχιστον μία αυτόματη ανάθεση βάρδιας (βλ. Ενότητα @sec:design:prototypes:scheduleWizard). Ο σχηματισμός του αλγορίθμου από μαθηματικής πλευράς έχει αναλυθεί εκτενώς στην Ενότητα @sec:literature:nurseScheduling:model. Στην Ενότητα αυτή, υλοποιούμε τον αλγόριθμο προγραμματιστικά, και τον ενσωματώνουμε στο front-end της εφαρμογής.

Από αρχιτεκτονικής άποψης, επιλέγουμε η μηχανή να είναι κεντρικοποιημένη, δηλαδή να εκτελείται απομακρυσμένα σε έναν εξυπηρετητή, και όχι στην εκάστοτε συσκευή του χρήστη, παράλληλα με το front-end. Η επιλογή αυτή γίνεται κυρίως για δύο λόγους.

Πρώτον, η πιο δημοφιλής γλώσσα που επιλέγεται για την επίλυση προβλημάτων γραμμικού προγραμματισμού είναι συνήθως η Python, λόγω της πληθώρας σχετικών βιβλιοθηκών. Έτσι, υπάρχει αναντιστοιχία με τη γλώσσα προγραμματισμού του front-end, που είναι η Dart, και άρα εμφανίζεται η ανάγκη υλοποίησης ενός API, που θα πραγματοποιεί τη διασύνδεση των δύο τμημάτων.

Δεύτερον, το περιβάλλον εκτέλεσης του front-end της εφαρμογής είναι πλήρως μη ελεγχόμενο, τόσο από πλευράς πλατφόρμας (και άρα υποστήριξης της Python), όσο και από πλευράς υπολογιστικής ισχύος. Έτσι, εάν επιλέγαμε να υλοποιήσουμε τη μηχανή αποκεντρωμένα, παράλληλα με το front-end σε κάθε συσκευή, θα έπρεπε πάντα να εξασφαλίζουμε ότι η Python είναι εγκατεστημένη στο σύστημα, μαζί με όλες τις απαραίτητες βιβλιοθήκες. Όσον αφορά την υπολογιστική ισχύ, η φύση του αλγορίθμου και η πολυπλοκότητα του προβλήματος δεν έχουν ιδιαίτερες απαιτήσεις. Παρ' όλα αυτά, θα ήταν καλή πρακτική να απομονώσουμε την εκτέλεση της μηχανής σε έναν εξυπηρετητή που λειτουργεί καθαρά επί τούτου, κυρίως λόγω της αβεβαιότητας περί της υφιστάμενης συσκευής και πλατφόρμας.

Επιλέγουμε, λοιπόν, να υλοποιήσουμε τη μηχανή σε Python. Η [PuLP](https://pypi.org/project/PuLP/) είναι μία βιβλιοθήκη της Python, που υλοποιεί εσωτερικά δημοφιλείς αλγορίθμους γραμμικού προγραμματισμού, με σκοπό την επίλυση τέτοιων προβλημάτων. Το μοντέλο της μηχανής είναι πολύ απλούστερο από αυτό του front-end και περιλαμβάνει μονάχα τις απαραίτητες για τον ορισμό του προβλήματος γραμμικού προγραμματισμού οντότητες του μοντέλου δεδομένων (βλ. Ενότητα @sec:implementation:dataModel), όπως τις *Employee*, *ShiftType*, *ShiftAssignment* και *Schedule*, τα απαιτούμενα χαρακτηριστικά και οι συσχετίσεις τους.

Για την επίλυση του προβλήματος, εισάγουμε τους απαραίτητους περιορισμούς, όπως περιγράφονται στην Ενότητα @sec:literature:nurseScheduling:model. Υπενθυμίζουμε ότι οι περιορισμοί αυτοί εκφράζονται με τη μορφή αθροισμάτων των τιμών των μεταβλητών απόφασης, προστίθενται στο μοντέλο γραμμικού προγραμματισμού, επηρεάζοντας την αντικειμενική συνάρτηση και είναι οι ακόλουθοι:

- Το πολύ μία ανάθεση ανά εργαζόμενο, ανά ημέρα (ή καμία, αν έχει ζητηθεί ρεπό ή άδεια).
- Μέγιστος αριθμός αναθέσεων εντός του χρονικού ορίζοντα (του εύρους του αντικειμένου *Schedule*).
- Μέγιστος αριθμός αναθέσεων σε συνεχόμενες ημέρες
- Απαγόρευση ανάθεσης σε νυχτερινή βάρδια και στην αμέσως επόμενη πρωινή

Οι περιορισμοί αυτοί είναι ενσωματωμένοι στον κώδικα στην πλευρά του εξυπηρετητή και ισχύουν για όλα τα προγράμματα εργασίας όλων των οργανισμών, χωρίς δυνατότητα επεξεργασίας.

Ο αλγόριθμος δέχεται ως είσοδο τις ημέρες του προγράμματος εργασίας, τους τύπους βαρδιών, τον αριθμό αναθέσεων που πρέπει να πραγματοποιηθούν, τους διαθέσιμους εργαζομένους και τις προτιμήσεις τους. Ο αλγόριθμος παράγει ως έξοδο τις τιμές των μεταβλητών απόφασης που δημιουργήθηκαν, και οι οποίες καθορίζουν τις αναθέσεις που πραγματοποιήθηκαν, με τη μορφή *True / False* (True εάν ο συγκεκριμένος εργαζόμενος ανατέθηκε στη συγκεκριμένη βάρδια, αλλιώς False).

### Υλοποίηση εξυπηρετητή {#sc:implementation:server:API}

Για την ενσωμάτωση της μηχανής στο front-end, κατασκευάζουμε ένα REST API με [Flask](https://flask.palletsprojects.com/en/3.0.x/), μία από τις πιο γνωστές βιβλιοθήκες της Python για αυτόν τον σκοπό. Το front-end πραγματοποιεί αιτήματα HTTP σε ένα endpoint αυτού του API. Στη συνέχεια, το API, αφού διαχειριστεί κατάλληλα τα δεδομένα που έλαβε από το αίτημα HTTP, καλεί τον αλγόριθμο αυτόματης ανάθεσης, με τις κατάλληλες εισόδους. Έπειτα, με την ολοκλήρωση της εκτέλεσης του αλγορίθμου, το API λαμβάνει την έξοδο και, αφού τη διαχειριστεί κατάλληλα, στέλνει στο front-end μία απόκριση HTTP με τα αποτελέσματα της αυτόματης ανάθεσης. Καθ' όλη αυτή τη διάρκεια, το front-end παραμένει στάσιμο, υποδεικνύοντας στον χρήστη ότι εκτελείται λειτουργία στο παρασκήνιο, με έναν δείκτη προόδου (progress indicator).

Ο εξυπηρετητής αυτός, καθώς πρέπει να είναι πάντα προσβάσιμος από όλες τις συσκευές, πρέπει να φιλοξενείται σε μία υπηρεσία νέφους (cloud hosting). Για τον σκοπό αυτό, επιλέγουμε την υπηρεσία [Fly](https://fly.io/). Το Fly φιλοξενεί full-stack εφαρμογές ιστού και παρέχει υποστήριξη για διασύνδεση με βάσεις δεδομένων, εικονικές μηχανές, μονάδες επεξεργασίας γραφικών (GPU) και άλλα. Επιλέξαμε τη συγκεκριμένη υπηρεσία λόγω προϋπάρχουσας εμπειρίας από εργασίες εξαμήνων.
